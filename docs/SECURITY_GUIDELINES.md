# Security Guidelines (Global Standard)

プロダクト横断で守る最高レベルのセキュリティ基準。実装・運用・レビューの判断軸とし、例外は理由と期限を明示する。

## 基本原則
- 最小権限: ユーザー・サービス・トークンは必要最小限のスコープ/ロールのみ付与する。
- 安全デフォルト: 設定やフラグは安全側を初期値にし、明示的に有効化させる。
- 防御の多層化: クライアント/サーバ/DB/ネットワーク/CIの各層で防御を持つ。
- 検証と監査: すべての入力・設定・依存を検証し、変更とアクセスを記録・レビューする。

## 認証・認可
- 強制HTTPS・HSTSを有効化。Cookieは `Secure`, `HttpOnly`, `SameSite=strict` を原則。
- セッション/トークンは短寿命・ローテーション・失効（revoke）を前提に設計。
- RBAC/ABACで権限を明示。サーバサイドで必ず再検証し、UI側の制御に依存しない。
- 管理系機能は追加防御（IP制限、MFA必須、監査ログ強化）を敷く。

## 入力・API防御
- すべての外部入力をホワイトリスト型でバリデーション。型・長さ・フォーマット・範囲を明示する。
- SQL/ORMはプレースホルダ使用。NoSQLもキー/値/演算子をサニタイズ。
- 出力時は文脈エスケープ（HTML/JS/URL/属性）。リッチテキストはサニタイザを通す。
- レートリミットとボット対策をAPI・認証エンドポイントに適用。再試行に指数バックオフ。

## 機密情報と設定
- シークレットは環境変数/シークレットマネージャで管理し、リポジトリに置かない。`.env` は暗号化ストレージに限定共有。
- コミット前にシークレット検出を実行し、漏洩時はキーをローテーションし影響範囲を調査・共有。
- APIキー・署名鍵は用途ごとに分離し、権限・レート・期限を絞る。

## データ保護
- 保存時暗号化（DB/バックアップ/オブジェクトストレージ）。転送時TLS。
- PII/機微データは収集最小化、マスキング/トークナイゼーションを検討。ログ/分析に原文を残さない。
- データ削除と保持期間をポリシー化し、自動クリーンアップを設定。

## 依存関係とビルド
- 依存はバージョンピン留めし、SCA（脆弱性スキャン）をCIに組み込む。重大度に応じて自動PRを適用。
- 不要な依存を削除し、transitive依存のライセンスも確認。ビルド成果物に不要ファイルを含めない。

## CI/CDと環境
- CIランナーの権限は最小化し、シークレットは環境別に分離。PRから本番シークレットへアクセスさせない。
- インフラ変更はIaCでコード化し、レビュー必須。デプロイは署名付きアーティファクトを使用。
- 環境間（dev/stg/prod）の分離を明確化し、データ混入を防ぐ（本番データを開発環境に持ち込まない）。

## ログ・監査・アラート
- 認証/権限変更/設定変更/デプロイ/データエクスポートは監査ログを残し、改ざん防止ストレージに保管。
- アプリログはPIIを最小化し、トレースID/リクエストIDを付与。レベル設定を環境で切り替える。
- 重要なエラーや異常（認証失敗スパイク、レートリミット超過、WAFブロック）はアラートを通知。

## クライアント（Web/モバイル）
- CSP/Referrer-Policy/X-Frame-Options/X-Content-Type-Options/Permissions-Policy を適用。
- ローカルストレージに機微情報を保存しない。必要ならセキュアなCookieかOSキーストアを利用。
- クリックジャッキング・オープンリダイレクト・XSSを防ぐため、ナビゲーション先のホワイトリストと入力エスケープを徹底。

## インシデント対応
- 重大度定義とエスカレーション経路を決め、オンコールを明示。初動（封じ込め→根本原因→復旧→再発防止）を標準化。
- インシデント後はポストモーテムを実施し、学びをガイドラインと実装に反映。

## レビュー・チェックリスト（抜粋）
- 認証/認可はサーバ側で必ず検証しているか？
- シークレットや機微データがコード/ログ/エラーに残っていないか？
- すべての外部入力に型・範囲チェックとエスケープを適用しているか？
- 危険操作に監査ログとレートリミット/CSRF対策があるか？
- 依存・CI/CD・インフラの権限が最小化されているか？
